[{"title":"自学心理学1个月——开篇","date":"2017-12-25T16:00:00.000Z","path":"2017/12/26/自学心理学1个月——开篇/","text":"哈罗，我是你们的神奇的小伙伴——Zoe 岑小荋（小耳朵） 今天我突发奇想，想要学习心理学，为期1个月。一个月的时间是很短暂的，并不会要求自己能够学习到特别多，特别专业的东西，只是想要带着自己入个门： 至少能够看到一些最基本的心理名词，心理现象，一些心理学的大咖，心理学的基本分类，最厉害的心理学研究所，厉害的大学的心理学排名（分为国内版本，国外版本，综合版本）等等。所以我把1个月分为4个星期。一共是四个主题。 1. 著名的心理学大咖及他的故事 2. 著名的心理学研究所及相关成就 3. 著名的但是容易被人忽视的日常心理现象 4. 厉害的大学的心理学排名 期待我每周能够在周日发表一篇高质量的帖子。 佛洛依德 送上一张佛洛依德老爷子的照片，好吧，作为一个目前还属于心理学小白的我，也想不出来有比他更具有影响力的人了。加油哦，学霸学神们快来附身我这个学沫沫吧 ！！！~","tags":[{"name":"你好世界","slug":"你好世界","permalink":"http://yoursite.com/tags/你好世界/"},{"name":"点滴","slug":"点滴","permalink":"http://yoursite.com/tags/点滴/"},{"name":"起步","slug":"起步","permalink":"http://yoursite.com/tags/起步/"},{"name":"心理学","slug":"心理学","permalink":"http://yoursite.com/tags/心理学/"},{"name":"开篇","slug":"开篇","permalink":"http://yoursite.com/tags/开篇/"}]},{"title":"被遗忘的关键第四期","date":"2017-09-04T16:00:00.000Z","path":"2017/09/05/被遗忘的关键第四期/","text":"通常我们把出生0-3个月的宝宝叫做新生儿。胎龄在37足周以前出生的宝宝叫做早产儿。这是我们通常对新生儿以及早产儿的定义，但是全美顶级儿科医生、儿童成长专家卡普博士提出了一个观点：人类都是早产儿。 为什么认为人类都是早产儿呢? 首先，我们来了解早产儿的情况。相信每一位早产儿妈妈都会希望宝宝能够在肚子里多待一天，要知道，据科研结果表明，宝宝在妈妈的子宫里，大脑会每分钟增加25万个神经细胞，身体会变得越来越精密发达。但是一旦宝宝出生，宝宝高速发展就被打断了，新生儿是不会低声咕哝，更不会说话，甚至连自己安抚自己吮吸手指的动作都完成不了。对比动物界其他的生物，比如小牛犊，牛犊正常出生后不久就可以站立并且行走，但是婴儿却要经历接近1年的时间才可以进入行走的阶段。这是因为胎儿在妈妈体内度过了9个月的时间，按照3个月为一个时期，胎儿在妈妈的体内经历了3个时期。但是实际上，他们还需要额外的3个月时间来帮助他们发育成长。因此，出生后的三个月，被称为婴儿的“第四期”。 为什么婴儿的第四期需要在出生后完成呢？ 据考古学家的研究，很久以前，婴儿是需要在妈妈肚子里待够12个月才出生。因为当时人们的大脑并没有现代人这么发达，所以他们的脑容量小，头部也小。随着人类的进化，人类逐渐成为脑部高度发达的生物，大脑逐渐发育，头部变大。妈妈在生产过程遇见了问题，因为胎儿的头部过大可能在出生过程中被卡在产道里。所以人类在大自然中又开始进化，卡普博士认为，人类在自然界进化过程中，做了下列四种调整： 胎儿开始丢弃一些刚出生暂时用不到的技能，发展实用大脑，只保留一些基本的原始反射和生存技能，比如，心跳等。这可以类比，需要出门旅行，但是我们不能把整个家都带到外地去，我们必须有选择地精减行李，只带少量必需品。 胎儿的头部形状变得光滑，圆润，并且为了生产方便，内部的大脑还具有可压缩性，帮助胎儿在生产过程中不至于被卡住。 胎儿在生产过程中，头部可以旋转，这样方便胎儿出生。 胎儿的出生日期被提前到9个月。 因此，我们见到的新生儿本来都是应该还在妈妈柔软的子宫里面待着，远离一切饥饿，细菌，寒冷和各种危险，但是由于上述原因，提早降生了。 婴儿的第四时期真的有存在的必要吗？ 新生儿的身体都是柔软而脆弱的，他们有时候呼吸还不规律，不会说话，不能表达自己的需求，没有办法跟外界沟通，我们需要尽量给处于第四时期的婴儿提供类似子宫的环境。为什么这样说呢，相信家长都会比较熟悉困扰宝宝的一种症状“腹绞痛”，但是在一些现代文明影响较少的古朴村落中，腹绞痛基本不会出现，这是为什么呢？ 据卡普医生的书《卡普新生儿安抚法》中提到，在巴厘岛的一些古老的村落，宝宝出生后的105天内，人们都会一直抱着婴儿，即使睡觉时，也不会放下宝宝，宝宝一哭就给宝宝喂奶。这样的代养方式，就好像宝宝还在妈妈的子宫里，一直被抱着就像时刻被妈妈的子宫包围，宝宝一哭就给宝宝喂奶，就好像宝宝和妈妈还是用一根脐带相连接，及时给宝宝输送养分。等到第105天到来时，巴厘岛古老村落的村民会举行一个神圣的仪式，庆祝婴儿的降生，此前村民一直认为，未满105天的婴儿属于上帝，因此，在这个地方的婴儿几乎不会出现婴儿腹绞痛的现象，究其原因是，婴儿有了更多的第四期，类似子宫环境体验，满足他们第四期的需求。 宝宝的第四期在生活中有具体的运用吗？ 日常生活中，妈妈们可能都会困扰，为什么新生儿总是会很喜欢被抱着睡，被摇着睡，还有一部分新生儿需要奶睡。新生儿的这些表现，都与第四期有密切的关系。因为抱睡可以让宝宝体验到在妈妈子宫里面被包裹的感觉。摇睡可以帮助宝宝体验在妈妈子宫里，妈妈移动时的感觉。奶睡，是宝宝最高的安抚方式，能够与妈妈进行肌肤接触，满足宝宝与妈妈之间的情感链接的需求。所以在宝宝的第四时期，我们要尽量满足宝宝的需求，进行亲密育儿。 人类都是早产儿，如果给宝宝增加在第四时期类子宫环境的体验，可以帮助宝宝缓解腹绞痛，同时，也可以践行亲密育儿的育儿理念，帮助宝宝更好地成长。 参考资料：《最快乐宝宝1• 卡普新生儿安抚法》","tags":[{"name":"早产儿","slug":"早产儿","permalink":"http://yoursite.com/tags/早产儿/"},{"name":"新生儿","slug":"新生儿","permalink":"http://yoursite.com/tags/新生儿/"}]},{"title":"把node捡起来之buffer","date":"2017-08-07T16:00:00.000Z","path":"2017/08/08/buffer/","text":"最近感觉很痛苦，再别人学习新语言新框架的时候，自己却在原地踏步，实在是对自己感到可悲，于是开始着手学习一门后台语言，学习后天语言并不是一时兴起想去学的，而是看现在的趋势，还有是自己的兴趣。js其实我觉得是一门很友好的语言，在踩过基础坑之后，觉得自己应该取扩展一些强数据类型的语言，一是想多了解，二是可以把自己道路拓宽，于是就在想，我应该适合学什么语言，公司现在后台有用java和php，虽然java是使用率最高的语言而php有一句话不是说么”世界上最好的语言是PHP”,但是也许是个人原因，我对php和java都不会感兴趣，java不感兴趣是因为当初找工作的时候总有java打电话，问有没有兴趣培训java的，所以我觉的会不会学java的人太多了？当然都是我自己偏见，而php呢，是因为身边很多用php的码农，我觉的用php好像很”随便”，这在我的理解就是随便的编码格式，随便的…好吧，其实都是我得偏见，最终选择Go语言是因为我在一年前就对它有一些了解，然后机缘巧合，找到了一些学习资料，然后就开始着手学习起来……跑题了…为啥又捡起来node了呢，node这个作为js写的”后台”首先js的基础学习成本减少了，而且使用各种包又算式比较得心应手，上周看一篇js爬虫抓取数据的例子，然后自己正好有这个需求，于是就想再重开始把node过一遍。–当然还有最主要的是我并不满足只满足现在公司的需求“只对str与DOM做一些操作” buffer 像之前说的，js是很友好的，比如字符串12console.log(&quot;123&quot;.length)//3console.log(&quot;你的名字&quot;.length)//4 在大多数语言中的汉字都是占3个字节的，而js只占1个 因为在node中，应用需要处理网络协议.操作数据库.处理图片.接收上传文件等.还要处理大量的二进制数据，js中的str不能满足需求，所以就应运而生了Buffer对象； 结构 Buffer是一个像Array结构的对象，它的元素为16进制的两位数（0~255），但是它主要用于操作字节； Buffer对象 我们可以分配一个Buffer对象，指定它的字节； 12var buf = new Buffer(100)console.log(buf.length) 当然我们也可以像“数组”一样继续操作它，如：获取它第10个字节 1console.log(buf[10]) 或者给它第10个字节赋值 12buf[10] = 100console.log(buf) 这里有一个很重要的一点，当赋值范围不在0~255之间的时候，该值就会逐次加256，直到得到0~255之间的整数，当大于的时候逐次减256，如果是小数舍弃小数部分只保留整数部分 Buffer内存分配机制Buffer对象的内存分配不是在V8的堆内存中，而是在Node的C++层面实现内存的申请的，也就是C++先去想系统内存申请一些内存给Node用，每次Node需要用的时候再由C++分配给Node,而不是Node每次需要用内存就去找系统要，这样系统压力很大的。（这里废话好像多，可以略过） 总之12345var poolfunction allocPool()&#123; pool = new SlowBuffer(Buffer.poolSize); pool.used = 0;&#125; &lt;-used:08&nbsp;BK的poolNode采用的是slab内存分配机制，新建一个局部变量pool，处于分配状态的slab都指向它，slab具有三种状态 full:完全分配状态 partial:部分分配状态 empty:没有分配状态1var buf = new Buffer(8*1024) Node以8KB为界限来区分是大对象和小对象(&lt;8KB就按照小对象的方式分配) 小对象：会记录起始长度（offset），以及当前pool使用的长度。(如果第二个Buffer大于剩下的空间，则再新建一个pool)&lt;-offset:0Buffer1&lt;-used:20488&nbsp;BK的pool 大对象：将会直接分配一个SlowBuffer作为slab单元，这个单元将会被这个大Buffer独占； Buffer的转换 支持转换的类型 ASCII UTF-8 UTF-16LE/UCS-2 Base64 Binary Hex 通过new Buffer(str, [encoding])创建buf.write(string,[offset],[length],[encoding])写入（就是修改，不能新增）buf.toString([encoding],[start],[end])转换123var buf = new Buffer(&quot;我是&quot;,&quot;utf-8&quot;);console.log(buf);console.log(buf.toString(&quot;utf-8&quot;,0,6)); 比较遗憾的是Node的Buffer对象支持的编码类型有限，于是提供Buffer.isEncoding([encoding])的方法判断是否支持转换 12console.log(Buffer.isEncoding(&quot;utf-8&quot;));//trueconsole.log(Buffer.isEncoding(&quot;utf-16&quot;));//false [GBK.GB2312.BIG-5]等都不支持 当然在Node中不可转换的可以借助其他模块来完成转换。iconv（C++调用libiconv库）和iconv-lite（纯javascript）两个模块可以支持更多的编码转换 如:iconv-lite12345var iconv = require(&quot;iconv-lite&quot;);//Buffer 转字符串var str iconv.decode(buf,&quot;win1251&quot;)//字符串 转Buffervar buf = iconv.encode(&quot;im string&quot;,&quot;win1251&quot;) Buffer的拼接 先来一段从输入流中读取内容的示例1234567891011var fs = require(&quot;fs&quot;);var rs = fs.createReadStream(&apos;demo.go&apos;);var data = &apos;&apos;;rs.on(&quot;data&quot;,function (chunk) &#123; console.log(chunk); //等价于 data = data.toString() + chunk.toString() data+=chunk&#125;);rs.on(&quot;end&quot;,function () &#123; console.log(data);&#125;) 这样子写没有问题，会输出demo.go中的Go语言的代码，但是如果换成不能解析的就会乱码，像中文，图片，视频等，因为这里的Buffer已经当字符串处理了，我们用的+=,等同于data = data.toString() + chunk.toString(),因为在中文场景下Buffer的长度受到了影响，必须还是刚才的代码，我们重现一下报错1var rs = fs.createReadStream(&apos;demo.go&apos;,&#123;highWaterMark:11&#125;); 限制了一下每次读取的长度就会产生乱码因为中文在utf-8中显示三个字节，而截断之后只要遇到一个汉字被截断之后每个字节就会以�来显示 setEncoding()中的string_decoder()上面的Buffer拼接出现乱码确实令人头痛，当然Buffer长度越大也就越不会出现上面的问题，但是这并不是解决办法，这个问题是不可以忽视的。 于是想到了setEncoding()方法，12var rs = fs.createReadStream(&apos;main.go&apos;,&#123;highWaterMark:11&#125;);rs.setEncoding(&quot;utf-8&quot;) 这下就可以完整输出中文了1234567var StringDecoder = require(&apos;string_decoder&apos;).StringDecoder;var decoder = new StringDecoder(&apos;utf-8&apos;);var buf1 = new Buffer([0xE5, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA, 0xBA])//这个buffer请忽略console.log(decoder.write(buf1));var buf2 = new Buffer([0xE5, 0xBA, 0xBA, 0xBA])//这个buffer请忽略console.log(decoder.write(buf2)); 原理：在调用setEncoding方法时，可读流内部设置了一个decoder对象，该对象来于string_decoder模块StringDecoder的实例对象，它神奇的地方就在于它知道宽字节字符串在utf-8中是以3个字节的方式储存，所以在第一次write()的时候只把转成的字符，而“半个”字符中的字节保存在StringDecoder的实例内部，第二次write()的时候将剩余的字节与第二次开始的字节合并成一个完整的字节在第二次输出。虽然string_decoder模块很奇妙，但是它并不是万能的，它目前只能处理utf-8.Base64和UCS-2/UTF-16LE这三种编码，虽然他能解决大部分编码问题，但不能从根本上解决该问题 正确的拼接方式 舍弃了setEncoding之后，解决方法是把Buffer小对象拼接橙一个Buffer大对象。然后用iconv-lite一类的模块进行转换1234567891011121314var fs = require(&quot;fs&quot;);var iconv = require(&quot;iconv-lite&quot;);var rs = fs.createReadStream(&apos;sh.go&apos;,&#123;highWaterMark:11&#125;);var size = 0;var chunks = [];rs.on(&quot;data&quot;,function (chunk) &#123; chunks.push(chunk); size+=chunk.length&#125;);rs.on(&quot;end&quot;,function () &#123; var buf = Buffer.concat(chunks,size); var str = iconv.decode(buf,&quot;utf-8&quot;); console.log(str);&#125;); Buffer.concat方法和js数组的拼接.concat方法不相同，前者是封装了从小Buffer对象向大Buffer对象复制的过程。源码确实写得很细腻，如下： 12345678910111213141516171819202122232425262728Buffer.concat = function(list,length)&#123; if(!Array.isArray(list))&#123;//判断传入list是否是数组 throw new Error(&quot;Usage: Buffer.concat(list,[length])&quot;); &#125; if(list.length == 0)&#123; return new Buffer(0);//传入数组为空时创建一个空Buffer &#125;else if(list.length === 1)&#123; return list[0];//传入数组为1的时直接返回第一个Buffer作为最终Buffer &#125; if(typeof length !== &apos;number&apos;)&#123;//如果未传入length，或者传入的不是&apos;number&apos;类型，自循环获取 length = 0; for(var i = 0; i &lt;list.length; i++)&#123; var buf = list[i]; length += buf.length; &#125; &#125; var buffer = new Buffer(length);//创建一个所有子Buffer总长的Buffer; var pos = 0; for(var i = 0; i &lt; list.length; i++)&#123; var buf = list[i]; buf.copy(buffer,pos);//*使用copy方法复制子项插入到总Buffer中，并且制定插入的位置 pos+=buf.length;//*每次插入之后把刚才copy子项的长度记录，保证下次插入位置正确 &#125; return buffer;&#125; 总结，摆脱string的思维定势，注意Buffer与Sting之间的差异，后续还有Buffer与性能，暂时还没有整理；","tags":[{"name":"node","slug":"node","permalink":"http://yoursite.com/tags/node/"},{"name":"buffer","slug":"buffer","permalink":"http://yoursite.com/tags/buffer/"},{"name":"buffer1","slug":"buffer1","permalink":"http://yoursite.com/tags/buffer1/"},{"name":"buffer2","slug":"buffer2","permalink":"http://yoursite.com/tags/buffer2/"}]},{"title":"Hello World","date":"2017-05-31T16:00:00.000Z","path":"2017/06/01/hello-world/","text":"用于记录学到的点滴 –@cenxiaoer 1console.log(\"Hello World!\")","tags":[{"name":"开始","slug":"开始","permalink":"http://yoursite.com/tags/开始/"},{"name":"helloWorld","slug":"helloWorld","permalink":"http://yoursite.com/tags/helloWorld/"},{"name":"你好世界","slug":"你好世界","permalink":"http://yoursite.com/tags/你好世界/"},{"name":"console","slug":"console","permalink":"http://yoursite.com/tags/console/"},{"name":"点滴","slug":"点滴","permalink":"http://yoursite.com/tags/点滴/"},{"name":"起步","slug":"起步","permalink":"http://yoursite.com/tags/起步/"}]}]